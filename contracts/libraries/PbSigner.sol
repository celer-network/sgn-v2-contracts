// SPDX-License-Identifier: GPL-3.0-only

// Code generated by protoc-gen-sol. DO NOT EDIT.
// source: contracts/libraries/proto/signer.proto
pragma solidity >=0.5.0;
import "./Pb.sol";

library PbSigner {
    using Pb for Pb.Buffer; // so we can call Pb funcs on Buffer obj

    struct Signer {
        address account; // tag: 1
        uint256 power; // tag: 2
    } // end struct Signer

    function decSigner(bytes memory raw) internal pure returns (Signer memory m) {
        Pb.Buffer memory buf = Pb.fromBytes(raw);

        uint256 tag;
        Pb.WireType wire;
        while (buf.hasMore()) {
            (tag, wire) = buf.decKey();
            if (false) {}
            // solidity has no switch/case
            else if (tag == 1) {
                m.account = Pb._address(buf.decBytes());
            } else if (tag == 2) {
                m.power = Pb._uint256(buf.decBytes());
            } else {
                buf.skipValue(wire);
            } // skip value of unknown tag
        }
    } // end decoder Signer

    struct SortedSigners {
        Signer[] signers; // tag: 1
    } // end struct SortedSigners

    function decSortedSigners(bytes memory raw) internal pure returns (SortedSigners memory m) {
        Pb.Buffer memory buf = Pb.fromBytes(raw);

        uint256[] memory cnts = buf.cntTags(1);
        m.signers = new Signer[](cnts[1]);
        cnts[1] = 0; // reset counter for later use

        uint256 tag;
        Pb.WireType wire;
        while (buf.hasMore()) {
            (tag, wire) = buf.decKey();
            if (false) {}
            // solidity has no switch/case
            else if (tag == 1) {
                m.signers[cnts[1]] = decSigner(buf.decBytes());
                cnts[1]++;
            } else {
                buf.skipValue(wire);
            } // skip value of unknown tag
        }
    } // end decoder SortedSigners
}
