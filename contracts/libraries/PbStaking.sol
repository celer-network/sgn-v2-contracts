// SPDX-License-Identifier: GPL-3.0-only

// Code generated by protoc-gen-sol. DO NOT EDIT.
// source: contracts/libraries/proto/staking.proto
pragma solidity >=0.5.0;
import "./Pb.sol";

library PbStaking {
    using Pb for Pb.Buffer; // so we can call Pb funcs on Buffer obj

    struct Reward {
        address recipient; // tag: 1
        uint256 cumulativeReward; // tag: 2
    } // end struct Reward

    function decReward(bytes memory raw) internal pure returns (Reward memory m) {
        Pb.Buffer memory buf = Pb.fromBytes(raw);

        uint256 tag;
        Pb.WireType wire;
        while (buf.hasMore()) {
            (tag, wire) = buf.decKey();
            if (false) {}
            // solidity has no switch/case
            else if (tag == 1) {
                m.recipient = Pb._address(buf.decBytes());
            } else if (tag == 2) {
                m.cumulativeReward = Pb._uint256(buf.decBytes());
            } else {
                buf.skipValue(wire);
            } // skip value of unknown tag
        }
    } // end decoder Reward

    struct Slash {
        address validator; // tag: 1
        address[] undelegators; // tag: 2
        uint64 nonce; // tag: 3
        uint64 slashFactor; // tag: 4
        uint64 infractionBlock; // tag: 5
        uint64 timeout; // tag: 6
        AcctAmtPair[] collectors; // tag: 7
    } // end struct Slash

    function decSlash(bytes memory raw) internal pure returns (Slash memory m) {
        Pb.Buffer memory buf = Pb.fromBytes(raw);

        uint256[] memory cnts = buf.cntTags(7);
        m.undelegators = new address[](cnts[2]);
        cnts[2] = 0; // reset counter for later use
        m.collectors = new AcctAmtPair[](cnts[7]);
        cnts[7] = 0; // reset counter for later use

        uint256 tag;
        Pb.WireType wire;
        while (buf.hasMore()) {
            (tag, wire) = buf.decKey();
            if (false) {}
            // solidity has no switch/case
            else if (tag == 1) {
                m.validator = Pb._address(buf.decBytes());
            } else if (tag == 2) {
                m.undelegators[cnts[2]] = Pb._address(buf.decBytes());
                cnts[2]++;
            } else if (tag == 3) {
                m.nonce = uint64(buf.decVarint());
            } else if (tag == 4) {
                m.slashFactor = uint64(buf.decVarint());
            } else if (tag == 5) {
                m.infractionBlock = uint64(buf.decVarint());
            } else if (tag == 6) {
                m.timeout = uint64(buf.decVarint());
            } else if (tag == 7) {
                m.collectors[cnts[7]] = decAcctAmtPair(buf.decBytes());
                cnts[7]++;
            } else {
                buf.skipValue(wire);
            } // skip value of unknown tag
        }
    } // end decoder Slash

    struct AcctAmtPair {
        address account; // tag: 1
        uint256 amount; // tag: 2
    } // end struct AcctAmtPair

    function decAcctAmtPair(bytes memory raw) internal pure returns (AcctAmtPair memory m) {
        Pb.Buffer memory buf = Pb.fromBytes(raw);

        uint256 tag;
        Pb.WireType wire;
        while (buf.hasMore()) {
            (tag, wire) = buf.decKey();
            if (false) {}
            // solidity has no switch/case
            else if (tag == 1) {
                m.account = Pb._address(buf.decBytes());
            } else if (tag == 2) {
                m.amount = Pb._uint256(buf.decBytes());
            } else {
                buf.skipValue(wire);
            } // skip value of unknown tag
        }
    } // end decoder AcctAmtPair
}
